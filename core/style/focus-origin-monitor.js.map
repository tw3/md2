{"version":3,"file":"focus-origin-monitor.js","sourceRoot":"","sources":["../../../../src/lib/core/style/focus-origin-monitor.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Injectable,\n  NgZone,\n  OnDestroy,\n  Optional,\n  Output,\n  Renderer,\n  SkipSelf\n} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {Subject} from 'rxjs/Subject';\n\n\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nexport const TOUCH_BUFFER_MS = 650;\n\n\nexport type FocusOrigin = 'touch' | 'mouse' | 'keyboard' | 'program';\n\n\ntype MonitoredElementInfo = {\n  unlisten: Function,\n  checkChildren: boolean,\n  renderer: Renderer,\n  subject: Subject<FocusOrigin>\n};\n\n\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\n@Injectable()\nexport class FocusOriginMonitor {\n  /** The focus origin that the next focus event is a result of. */\n  private _origin: FocusOrigin = null;\n\n  /** The FocusOrigin of the last focus event tracked by the FocusOriginMonitor. */\n  private _lastFocusOrigin: FocusOrigin;\n\n  /** Whether the window has just been focused. */\n  private _windowFocused = false;\n\n  /** The target of the last touch event. */\n  private _lastTouchTarget: EventTarget;\n\n  /** The timeout id of the touch timeout, used to cancel timeout later. */\n  private _touchTimeout: number;\n\n  /** Weak map of elements being monitored to their info. */\n  private _elementInfo = new WeakMap<Element, MonitoredElementInfo>();\n\n  constructor(private _ngZone: NgZone) {\n    this._ngZone.runOutsideAngular(() => this._registerDocumentEvents());\n  }\n\n  /**\n   * Monitors focus on an element and applies appropriate CSS classes.\n   * @param element The element to monitor\n   * @param renderer The renderer to use to apply CSS classes to the element.\n   * @param checkChildren Whether to count the element as focused when its children are focused.\n   * @returns An observable that emits when the focus state of the element changes.\n   *     When the element is blurred, null will be emitted.\n   */\n  monitor(element: Element, renderer: Renderer, checkChildren: boolean): Observable<FocusOrigin> {\n    // Check if we're already monitoring this element.\n    if (this._elementInfo.has(element)) {\n      let info = this._elementInfo.get(element);\n      info.checkChildren = checkChildren;\n      return info.subject.asObservable();\n    }\n\n    // Create monitored element info.\n    let info: MonitoredElementInfo = {\n      unlisten: null,\n      checkChildren: checkChildren,\n      renderer: renderer,\n      subject: new Subject<FocusOrigin>()\n    };\n    this._elementInfo.set(element, info);\n\n    // Start listening. We need to listen in capture phase since focus events don't bubble.\n    let focusListener = (event: FocusEvent) => this._onFocus(event, element);\n    let blurListener = (event: FocusEvent) => this._onBlur(event, element);\n    this._ngZone.runOutsideAngular(() => {\n      element.addEventListener('focus', focusListener, true);\n      element.addEventListener('blur', blurListener, true);\n    });\n\n    // Create an unlisten function for later.\n    info.unlisten = () => {\n      element.removeEventListener('focus', focusListener, true);\n      element.removeEventListener('blur', blurListener, true);\n    };\n\n    return info.subject.asObservable();\n  }\n\n  /**\n   * Stops monitoring an element and removes all focus classes.\n   * @param element The element to stop monitoring.\n   */\n  unmonitor(element: Element): void {\n    let elementInfo = this._elementInfo.get(element);\n\n    if (elementInfo) {\n      elementInfo.unlisten();\n      elementInfo.subject.complete();\n\n      this._setClasses(element, null);\n      this._elementInfo.delete(element);\n    }\n  }\n\n  /**\n   * Focuses the element via the specified focus origin.\n   * @param element The element to focus.\n   * @param renderer The renderer to use to invoke the focus method on the element.\n   * @param origin The focus origin.\n   */\n  focusVia(element: Node, renderer: Renderer, origin: FocusOrigin): void {\n    this._setOriginForCurrentEventQueue(origin);\n    renderer.invokeElementMethod(element, 'focus');\n  }\n\n  /** Register necessary event listeners on the document and window. */\n  private _registerDocumentEvents() {\n    // Note: we listen to events in the capture phase so we can detect them even if the user stops\n    // propagation.\n\n    // On keydown record the origin and clear any touch event that may be in progress.\n    document.addEventListener('keydown', () => {\n      this._lastTouchTarget = null;\n      this._setOriginForCurrentEventQueue('keyboard');\n    }, true);\n\n    // On mousedown record the origin only if there is not touch target, since a mousedown can\n    // happen as a result of a touch event.\n    document.addEventListener('mousedown', () => {\n      if (!this._lastTouchTarget) {\n        this._setOriginForCurrentEventQueue('mouse');\n      }\n    }, true);\n\n    // When the touchstart event fires the focus event is not yet in the event queue. This means\n    // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n    // see if a focus happens.\n    document.addEventListener('touchstart', (event: Event) => {\n      if (this._touchTimeout != null) {\n        clearTimeout(this._touchTimeout);\n      }\n      this._lastTouchTarget = event.target;\n      this._touchTimeout = setTimeout(() => this._lastTouchTarget = null, TOUCH_BUFFER_MS);\n    }, true);\n\n    // Make a note of when the window regains focus, so we can restore the origin info for the\n    // focused element.\n    window.addEventListener('focus', () => {\n      this._windowFocused = true;\n      setTimeout(() => this._windowFocused = false, 0);\n    });\n  }\n\n  /**\n   * Sets the focus classes on the element based on the given focus origin.\n   * @param element The element to update the classes on.\n   * @param origin The focus origin.\n   */\n  private _setClasses(element: Element, origin: FocusOrigin): void {\n    let renderer = this._elementInfo.get(element).renderer;\n    renderer.setElementClass(element, 'cdk-focused', !!origin);\n    renderer.setElementClass(element, 'cdk-touch-focused', origin === 'touch');\n    renderer.setElementClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n    renderer.setElementClass(element, 'cdk-mouse-focused', origin === 'mouse');\n    renderer.setElementClass(element, 'cdk-program-focused', origin === 'program');\n  }\n\n  /**\n   * Sets the origin and schedules an async function to clear it at the end of the event queue.\n   * @param origin The origin to set.\n   */\n  private _setOriginForCurrentEventQueue(origin: FocusOrigin): void {\n    this._origin = origin;\n    setTimeout(() => this._origin = null, 0);\n  }\n\n  /**\n   * Checks whether the given focus event was caused by a touchstart event.\n   * @param event The focus event to check.\n   * @returns Whether the event was caused by a touch.\n   */\n  private _wasCausedByTouch(event: FocusEvent): boolean {\n    // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n    // Consider the following dom structure:\n    //\n    // <div #parent tabindex=\"0\" cdkFocusClasses>\n    //   <div #child (click)=\"#parent.focus()\"></div>\n    // </div>\n    //\n    // If the user touches the #child element and the #parent is programmatically focused as a\n    // result, this code will still consider it to have been caused by the touch event and will\n    // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n    // relatively small edge-case that can be worked around by using\n    // focusVia(parentEl, renderer,  'program') to focus the parent element.\n    //\n    // If we decide that we absolutely must handle this case correctly, we can do so by listening\n    // for the first focus event after the touchstart, and then the first blur event after that\n    // focus event. When that blur event fires we know that whatever follows is not a result of the\n    // touchstart.\n    let focusTarget = event.target;\n    return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n        (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n  }\n\n  /**\n   * Handles focus events on a registered element.\n   * @param event The focus event.\n   * @param element The monitored element.\n   */\n  private _onFocus(event: FocusEvent, element: Element) {\n    // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n    // focus event affecting the monitored element. If we want to use the origin of the first event\n    // instead we should check for the cdk-focused class here and return if the element already has\n    // it. (This only matters for elements that have includesChildren = true).\n\n    // If we are not counting child-element-focus as focused, make sure that the event target is the\n    // monitored element itself.\n    if (!this._elementInfo.get(element).checkChildren && element !== event.target) {\n      return;\n    }\n\n    // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n    // 1) The window has just regained focus, in which case we want to restore the focused state of\n    //    the element from before the window blurred.\n    // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n    // 3) The element was programmatically focused, in which case we should mark the origin as\n    //    'program'.\n    if (!this._origin) {\n      if (this._windowFocused && this._lastFocusOrigin) {\n        this._origin = this._lastFocusOrigin;\n      } else if (this._wasCausedByTouch(event)) {\n        this._origin = 'touch';\n      } else {\n        this._origin = 'program';\n      }\n    }\n\n    this._setClasses(element, this._origin);\n    this._elementInfo.get(element).subject.next(this._origin);\n    this._lastFocusOrigin = this._origin;\n    this._origin = null;\n  }\n\n  /**\n   * Handles blur events on a registered element.\n   * @param event The blur event.\n   * @param element The monitored element.\n   */\n  private _onBlur(event: FocusEvent, element: Element) {\n    // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n    // order to focus another child of the monitored element.\n    if (this._elementInfo.get(element).checkChildren && event.relatedTarget instanceof Node &&\n        element.contains(event.relatedTarget)) {\n      return;\n    }\n\n    this._setClasses(element, null);\n    this._elementInfo.get(element).subject.next(null);\n  }\n}\n\n\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\n@Directive({\n  selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n})\nexport class CdkMonitorFocus implements OnDestroy {\n  @Output()\n  cdkFocusChange = new EventEmitter<FocusOrigin>();\n\n  constructor(private _elementRef: ElementRef, private _focusOriginMonitor: FocusOriginMonitor,\n              renderer: Renderer) {\n    this._focusOriginMonitor.monitor(\n        this._elementRef.nativeElement, renderer,\n        this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n        .subscribe(origin => this.cdkFocusChange.emit(origin));\n  }\n\n  ngOnDestroy() {\n    this._focusOriginMonitor.unmonitor(this._elementRef.nativeElement);\n  }\n}\n\n\nexport function FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY(parentDispatcher: FocusOriginMonitor,\n                                                      ngZone: NgZone) {\n  return parentDispatcher || new FocusOriginMonitor(ngZone);\n}\n\n\nexport const FOCUS_ORIGIN_MONITOR_PROVIDER = {\n  // If there is already a FocusOriginMonitor available, use that. Otherwise, provide a new one.\n  provide: FocusOriginMonitor,\n  deps: [[new Optional(), new SkipSelf(), FocusOriginMonitor], NgZone],\n  useFactory: FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY\n};\n"]}